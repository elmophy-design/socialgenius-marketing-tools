/**
 * backend/src/models/Tool.js
 * ToolContent Model - Stores Generated Content
 * 
 * Tracks all content generated by users across all 8 marketing tools
 */

import mongoose from 'mongoose';

/**
 * Tool Content Schema
 * Stores user-generated content from all tools
 */
const toolContentSchema = new mongoose.Schema({
  // User Reference
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    
  },

  // Tool Information
  toolId: {
    type: String,
    required: true,
    enum: [
      'social-media',
      'value-proposition',
      'headline-analyzer',
      'seo-meta',
      'email-tester',
      'content-idea',
      'ad-copy',
      'funnel-builder'
    ],
    index: true
  },

  toolName: {
    type: String,
    required: true,
    enum: [
      'Social Media Generator',
      'Value Proposition Generator',
      'Headline Analyzer',
      'SEO Meta Generator',
      'Email Subject Line Tester',
      'Content Idea Generator',
      'Ad Copy Generator',
      'Marketing Funnel Builder'
    ]
  },

  // Content Type
  contentType: {
    type: String,
    required: true,
    enum: [
      'social-post',
      'value-proposition',
      'headline',
      'seo-meta',
      'email-subject',
      'content-ideas',
      'ad-copy',
      'funnel'
    ]
  },

  // Platform (for platform-specific content)
  platform: {
    type: String,
    enum: ['facebook', 'twitter', 'instagram', 'linkedin', 'tiktok', 'google', null],
    default: null
  },

  // Input Data (what user provided)
  input: {
    type: mongoose.Schema.Types.Mixed,
    required: true
  },

  // Output Data (what was generated)
  output: {
    type: mongoose.Schema.Types.Mixed,
    required: true
  },

  // Title (for easier browsing)
  title: {
    type: String,
    trim: true,
    maxlength: 200
  },

  // Status
  status: {
    type: String,
    enum: ['draft', 'published', 'scheduled', 'archived'],
    default: 'draft'
  },

  // Favorites & Saving
  isSaved: {
    type: Boolean,
    default: false
  },

  isFavorite: {
    type: Boolean,
    default: false,
    index: true
  },

  // Scheduling (for social media posts)
  scheduledAt: {
    type: Date,
    default: null
  },

  publishedAt: {
    type: Date,
    default: null
  },

  // Analytics & Performance
  analytics: {
    views: {
      type: Number,
      default: 0,
      min: 0
    },
    clicks: {
      type: Number,
      default: 0,
      min: 0
    },
    engagement: {
      type: Number,
      default: 0,
      min: 0
    },
    conversions: {
      type: Number,
      default: 0,
      min: 0
    }
  },

  // Tags for organization
  tags: [{
    type: String,
    trim: true
  }],

  // Notes
  notes: {
    type: String,
    trim: true,
    maxlength: 1000,
    default: ''
  },

  // Version Control
  version: {
    type: Number,
    default: 1,
    min: 1
  },

  parentId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'ToolContent',
    default: null
  },

  // Soft Delete
  deletedAt: {
    type: Date,
    default: null
  },

  // Metadata
  metadata: {
    type: Map,
    of: mongoose.Schema.Types.Mixed,
    default: {}
  },

  // Timestamps
  createdAt: {
    type: Date,
    default: Date.now,
    immutable: true
  },

  updatedAt: {
    type: Date,
    default: Date.now
  }
}, {
  timestamps: true,
  collection: 'tool_contents'
});

// ============================================
// INDEXES
// ============================================

toolContentSchema.index({ userId: 1, toolId: 1 });
toolContentSchema.index({ userId: 1, isFavorite: 1 });
toolContentSchema.index({ userId: 1, createdAt: -1 });
toolContentSchema.index({ userId: 1, status: 1 });
toolContentSchema.index({ deletedAt: 1 });

// ============================================
// VIRTUALS
// ============================================

/**
 * Check if content is scheduled
 */
toolContentSchema.virtual('isScheduled').get(function() {
  return this.status === 'scheduled' && this.scheduledAt && this.scheduledAt > new Date();
});

/**
 * Check if content is published
 */
toolContentSchema.virtual('isPublished').get(function() {
  return this.status === 'published' && this.publishedAt !== null;
});

/**
 * Get days since creation
 */
toolContentSchema.virtual('daysSinceCreated').get(function() {
  const now = new Date();
  const diff = now - this.createdAt;
  return Math.floor(diff / (1000 * 60 * 60 * 24));
});

// ============================================
// METHODS
// ============================================

/**
 * Toggle favorite status
 */
toolContentSchema.methods.toggleFavorite = async function() {
  this.isFavorite = !this.isFavorite;
  await this.save();
  return this;
};

/**
 * Mark as published
 */
toolContentSchema.methods.publish = async function() {
  this.status = 'published';
  this.publishedAt = new Date();
  await this.save();
  return this;
};

/**
 * Schedule for later
 */
toolContentSchema.methods.schedule = async function(scheduledDate) {
  this.status = 'scheduled';
  this.scheduledAt = scheduledDate;
  await this.save();
  return this;
};

/**
 * Archive content
 */
toolContentSchema.methods.archive = async function() {
  this.status = 'archived';
  await this.save();
  return this;
};

/**
 * Soft delete
 */
toolContentSchema.methods.softDelete = async function() {
  this.deletedAt = new Date();
  await this.save();
  return this;
};

/**
 * Create a new version (duplicate)
 */
toolContentSchema.methods.createVersion = async function() {
  const newVersion = new this.constructor({
    userId: this.userId,
    toolId: this.toolId,
    toolName: this.toolName,
    contentType: this.contentType,
    platform: this.platform,
    input: this.input,
    output: this.output,
    title: this.title,
    version: this.version + 1,
    parentId: this._id
  });

  await newVersion.save();
  return newVersion;
};

/**
 * Update analytics
 */
toolContentSchema.methods.incrementViews = async function() {
  this.analytics.views += 1;
  await this.save();
  return this;
};

toolContentSchema.methods.incrementClicks = async function() {
  this.analytics.clicks += 1;
  await this.save();
  return this;
};

toolContentSchema.methods.incrementEngagement = async function() {
  this.analytics.engagement += 1;
  await this.save();
  return this;
};

toolContentSchema.methods.incrementConversions = async function() {
  this.analytics.conversions += 1;
  await this.save();
  return this;
};

// ============================================
// STATICS
// ============================================

/**
 * Get user's content by tool
 */
toolContentSchema.statics.getUserContentByTool = async function(userId, toolId) {
  return await this.find({
    userId,
    toolId,
    deletedAt: null
  }).sort({ createdAt: -1 });
};

/**
 * Get user's favorites
 */
toolContentSchema.statics.getUserFavorites = async function(userId) {
  return await this.find({
    userId,
    isFavorite: true,
    deletedAt: null
  }).sort({ createdAt: -1 });
};

/**
 * Get scheduled content
 */
toolContentSchema.statics.getScheduledContent = async function(userId) {
  return await this.find({
    userId,
    status: 'scheduled',
    scheduledAt: { $gte: new Date() },
    deletedAt: null
  }).sort({ scheduledAt: 1 });
};

/**
 * Get content analytics
 */
toolContentSchema.statics.getContentAnalytics = async function(userId) {
  const stats = await this.aggregate([
    {
      $match: {
        userId: new mongoose.Types.ObjectId(userId),
        deletedAt: null
      }
    },
    {
      $group: {
        _id: '$toolId',
        totalContent: { $sum: 1 },
        totalViews: { $sum: '$analytics.views' },
        totalClicks: { $sum: '$analytics.clicks' },
        totalEngagement: { $sum: '$analytics.engagement' },
        totalConversions: { $sum: '$analytics.conversions' }
      }
    }
  ]);

  return stats;
};

/**
 * Clean up old deleted content
 */
toolContentSchema.statics.cleanupDeleted = async function(daysOld = 30) {
  const cutoffDate = new Date();
  cutoffDate.setDate(cutoffDate.getDate() - daysOld);

  const result = await this.deleteMany({
    deletedAt: { $lt: cutoffDate }
  });

  return result.deletedCount;
};

// ============================================
// PRE HOOKS
// ============================================

/**
 * Update updatedAt timestamp
 */
toolContentSchema.pre('save', function(next) {
  this.updatedAt = new Date();
  next();
});

/**
 * Auto-generate title if not provided
 */
toolContentSchema.pre('save', function(next) {
  if (!this.title && this.output) {
    // Try to extract a title from the output
    if (this.output.headline) {
      this.title = this.output.headline;
    } else if (this.output.content) {
      this.title = this.output.content.substring(0, 100);
    } else if (this.output.subject) {
      this.title = this.output.subject;
    } else {
      this.title = `${this.toolName} - ${new Date().toLocaleDateString()}`;
    }
  }
  next();
});

// ============================================
// POST HOOKS
// ============================================

/**
 * Log content creation
 */
toolContentSchema.post('save', function(doc) {
  if (doc.isNew) {
    console.log(`âœ… Content created: ${doc.toolName} by user ${doc.userId}`);
  }
});

// ============================================
// QUERY HELPERS
// ============================================

/**
 * Find active content
 */
toolContentSchema.query.active = function() {
  return this.where({ deletedAt: null });
};

/**
 * Find favorites
 */
toolContentSchema.query.favorites = function() {
  return this.where({ isFavorite: true });
};

/**
 * Find by tool
 */
toolContentSchema.query.byTool = function(toolId) {
  return this.where({ toolId });
};

// ============================================
// TO JSON
// ============================================

/**
 * Clean up JSON output
 */
toolContentSchema.methods.toJSON = function() {
  const obj = this.toObject();
  delete obj.__v;
  return obj;
};

// ============================================
// EXPORT MODEL
// ============================================

const ToolContent = mongoose.model('ToolContent', toolContentSchema);

export default ToolContent;